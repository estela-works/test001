# 問題分析

> [← 目次に戻る](./README.md)

## 1. 従来のテストが前提としていたこと

### 1.1 関数の冪等性

従来の単体テストは「同じ入力に対して同じ出力を返す」という**冪等性**を暗黙的に前提としていた。

```javascript
// 従来の純粋関数
function add(a, b) {
  return a + b
}

// テストは簡単
expect(add(2, 3)).toBe(5)  // 何度実行しても同じ結果
```

### 1.2 関数に閉じた振る舞い

テスト対象の関数は、外部状態に依存せず、自己完結していた。

```javascript
// 入力と出力が明確
function formatPrice(price) {
  return `¥${price.toLocaleString()}`
}

// 外部依存がないためモックも不要
expect(formatPrice(1000)).toBe('¥1,000')
```

### 1.3 副作用の分離

副作用（API呼び出し、DOM操作など）は境界に集約され、ビジネスロジックと分離されていた。

```
[純粋なロジック] → テスト容易
       ↓
[副作用層] → モックで分離
```

---

## 2. モダンフロントエンドで崩れた前提

### 2.1 グローバルストアという共有状態

Vue (Pinia/Vuex) や React (Redux/Zustand) では、コンポーネント間で状態を共有するグローバルストアが存在する。

```javascript
// ストアの状態がコンポーネントの振る舞いを決定
const userStore = useUserStore()

function canEdit() {
  return userStore.currentUser.role === 'admin'
}
```

**問題**: `canEdit()` の結果は、ストアの状態という**外部要因**に依存する。

### 2.2 冪等性の喪失

同じコンポーネント、同じpropsでも、ストアの状態によって振る舞いが変わる。

```javascript
// 1回目の呼び出し（ストア: { count: 0 }）
increment()  // count → 1

// 2回目の呼び出し（ストア: { count: 1 }）
increment()  // count → 2  ← 同じ関数なのに結果が違う
```

### 2.3 状態空間の爆発

複数の状態が組み合わさることで、テストすべきケースが爆発的に増加する。

```
user.isLoggedIn × user.role × cart.items × ui.isModalOpen × ...

2 × 3 × n × 2 × ... = 組み合わせ爆発
```

### 2.4 従来のモック戦略の限界

| 従来の前提 | モダンFEの現実 |
|-----------|---------------|
| 依存は注入できる | ストアはグローバル |
| 状態は関数に閉じる | 状態は複数コンポーネントで共有 |
| 副作用は境界に集約 | 副作用がストアに散在 |
| モックは1箇所 | モックが複数箇所に波及 |
